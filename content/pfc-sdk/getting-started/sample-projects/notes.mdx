---
title: Notes on Sample Structure
description: Common patterns, engine lifecycle, and error handling across all samples
---

import { Callout } from 'fumadocs-ui/components/callout';

This page covers the common patterns and structures shared across all Perfectly Clear SDK sample projects.

## License lifecycle

All samples follow the same license pattern:

<Callout type="info">
The license validates online once every 12-24 hours. Ensure network connectivity for first activation.
</Callout>

### C/C++

```cpp
// At startup
int code = PFC_SetProtectionPath("/path/to/sdk_license");
if (code != 0) {
    printf("License error: %d\n", code);
}

// ... do work ...

// At shutdown
PFC_ReleaseProtectionPath();
```

### C#

```csharp
// License path passed to constructor
PerfectlyClear pfc = new PerfectlyClear(@"C:\path\to\sdk_license");

// ... do work ...

// Disposed automatically or call Dispose()
pfc.Dispose();
```

### CLI

```bash
# Option 1: Command line argument
./pfccmd --sdk-license /path/to/sdk_license input.jpg

# Option 2: Environment variable (recommended)
export PFC_SDK_LICENSE=/path/to/sdk_license
./pfccmd input.jpg
```

### Container

```bash
# Mount license folder
docker run -v "/path/to/sdk_license":/sdk_license pfc_container
```

## Engine lifecycle

<Callout type="warn">
AI engine initialization is expensive. Create once and reuse for multiple images.
</Callout>

### Recommended pattern

```cpp
// Create once at application startup
PFCENGINE *pEngine = PFC_CreateEngine();
int status = PFC_LoadAIEngine(pEngine, 
    AI_SCENE_DETECTION | AI_CORRECTIONS | AI_COLOR | AI_FACEMESH, 
    binPath);

// Reuse for each image
for (auto& imagePath : images) {
    PFCImageFile imageFile;
    imageFile.LoadImageFile(imagePath, true, NULL);
    
    PFCIMAGE im;
    // ... populate im ...
    
    PFCPARAM param;
    PFC_AutoCorrect(&im, NULL, param, -1, NULL, false, NULL, pEngine, true);
    
    imageFile.SaveImageFile(outputPath, 90, true, true);
}

// Destroy at application shutdown
PFC_DestroyEngine(pEngine);
```

### Thread safety

- `PFCENGINE` can be shared across threads for AI loading
- Each thread should use its own `PFCPARAM` and `PFCPROFILE`
- Image buffers must not be shared during processing

## AI feature flags

| Flag | Value | Description |
|------|-------|-------------|
| `AI_SCENE_DETECTION` | 0x01 | Automatic scene classification |
| `AI_CORRECTIONS` | 0x02 | Dynamic AI-based corrections |
| `AI_COLOR` | 0x04 | AI white balance correction |
| `AI_FACEMESH` | 0x08 | Advanced face detection |

### Loading and verifying

```cpp
int status = PFC_LoadAIEngine(pEngine, 
    AI_SCENE_DETECTION | AI_CORRECTIONS | AI_COLOR | AI_FACEMESH, 
    binPath);

// Check each feature
if ((status & AI_SCENE_DETECTION) == 0) {
    printf("Scene Detection failed to load\n");
}
if ((status & AI_CORRECTIONS) == 0) {
    printf("AI Corrections failed to load\n");
}
```

## Error handling

### Apply status codes

```cpp
int status = PFC_AutoCorrect(&im, ...);

if (status == APPLY_SUCCESS) {
    // Complete success
} 
else if (status > APPLY_SUCCESS) {
    // Partial success - check individual components
    printf("Noise Removal: %d\n", NRRETCODE(status));
    printf("Core: %d\n", CORERETCODE(status));
    printf("Face Beautification: %d\n", FBRETCODE(status));
    printf("Red Eye: %d\n", RERETCODE(status));
} 
else {
    // Failure
    printf("Error: %d\n", status);
}
```

### Common error codes

| Code | Meaning |
|------|---------|
| 0 | Success |
| -1 | General error |
| -2 | File not found |
| -6 | License error |
| -9 | Scene Detection preset (use `PFC_LoadScenePresets`) |
| > 0 | Partial success (check component codes) |

### C# error handling

```csharp
int result = pfc.AutoCorrect(ref bm);

switch (result)
{
    case (int)PFCAPPLYSTATUS.APPLY_SUCCESS:
        Console.WriteLine("Success");
        break;
    case (int)PFCAPPLYSTATUS.APPLY_ERROR_LICENSE:
        throw new Exception("License error");
    case (int)PFCAPPLYSTATUS.APPLY_ERROR_IMAGE:
        throw new Exception("Invalid image");
    default:
        if (result > 0)
            Console.WriteLine("Partial success");
        else
            throw new Exception($"Error: {result}");
        break;
}
```

## PFCIMAGE structure

All samples populate `PFCIMAGE` the same way:

```cpp
PFCIMAGE im;
im.width  = imageFile.width;      // Image width in pixels
im.height = imageFile.height;     // Image height in pixels
im.stride = imageFile.stride;     // Bytes per row (may include padding)
im.format = (PFCPIXELFORMAT)imageFile.pfcImageFormat();  // Pixel format
im.data   = imageFile.raw_image;  // Pointer to pixel data
```

### Pixel formats

| Format | Description |
|--------|-------------|
| `PFC_PixelFormat24bppRGB` | 24-bit RGB |
| `PFC_PixelFormat24bppBGR` | 24-bit BGR (Windows DIB) |
| `PFC_PixelFormat32bppARGB` | 32-bit ARGB |
| `PFC_PixelFormat32bppRGBA` | 32-bit RGBA |

## Color management

### Recommended workflow

1. **Load** with sRGB conversion (`bConvertToSRGB = true`)
2. **Process** in sRGB color space
3. **Save** with conversion back to original color space

```cpp
// Load
PFCImageFile imageFile;
bool bConvertToSRGB = true;
imageFile.LoadImageFile(inputPath, bConvertToSRGB, NULL);

// Process
// ... correction code ...

// Save - convert back to original
bool bConvertToOriginal = bConvertToSRGB;
bool bPreserveMetadata = true;
imageFile.SaveImageFile(outputPath, quality, bConvertToOriginal, bPreserveMetadata);
```

## Required files by platform

### Linux/macOS

```
libPerfectlyClearPro.a (or .so)
libPFCImageFile.a (or .so)
libPFCAIEngine.so
libonnxruntime.so.1.5.1
liblcms2.so.2
libexiv2.so.26
```

### Windows

```
PerfectlyClearPro.dll / .lib
PFCImageFile.dll
libPFCAIEngine.dll
onnxruntime.dll
lcms2.dll
libexiv2.dll
```

### AI models (all platforms)

```
pro_and_universal_20211221.pnn  # Scene Detection
dynamic.pnn                      # AI Corrections
aicolor.pnn                      # AI White Balance
skintone_20211221.pnn            # Skin Tone
facemesh.pnn                     # Face mesh
faceshape.pnn                    # Face shape
fdback.pnn                       # Face detection (back)
fdfront.pnn                      # Face detection (front)
v3.looks                         # Looks/LUTs
```

## Sample workflow comparison

| Step | SimpleAiSample | PresetSample | Standard-IO |
|------|----------------|--------------|-------------|
| License | `PFC_SetProtectionPath` | Same | Same |
| Load image | `LoadImageFile` | Same | `ExpandImageBuffer` (stdin) |
| Create engine | `PFC_CreateEngine` | Same | Same |
| Load AI | `PFC_LoadAIEngine` | Same | Same |
| Load preset | — | `PFC_ReadPresets` | `PFC_ReadPresets` |
| Correct | `PFC_AutoCorrect` | Same | Same |
| Get scene | `PFC_GetLastSceneProperties` | — | — |
| Save | `SaveImageFile` | Same | `CompressImageBuffer` (stdout) |
| Cleanup | `PFC_DestroyEngine` | Same | Same |

## Best practices

1. **Reuse engines** — Don't create/destroy for each image
2. **Check return codes** — Always verify success
3. **Use sRGB** — Process in sRGB, convert on save
4. **Preserve metadata** — Keep EXIF data when saving
5. **Handle partial success** — Check component status codes
6. **Thread-local params** — Don't share `PFCPARAM` across threads

## Next steps

- [C/C++ Samples](/docs/pfc-sdk/getting-started/sample-projects/c-cpp)
- [C# Samples](/docs/pfc-sdk/getting-started/sample-projects/csharp)
- [Windows Samples](/docs/pfc-sdk/getting-started/sample-projects/windows)
- [API Reference](/docs/pfc-sdk/api-reference)
